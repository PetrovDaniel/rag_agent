# Конспект по фреймворку LangGraph

**LangGraph** — это библиотека от команды LangChain, предназначенная для создания сложных, управляемых рабочими процессами (workflows) приложений на основе больших языковых моделей (LLM). Она позволяет строить графовые структуры, где узлы представляют действия или вычисления, а рёбра определяют порядок выполнения. LangGraph особенно полезен для создания агентов с управляемым состоянием, сложной логикой и циклическими процессами.

---

## Основные концепции LangGraph

1. **Граф (Graph)**:
   - LangGraph использует направленный граф для представления рабочего процесса.
   - Узлы (nodes): выполняют действия (например, вызов LLM, запуск инструмента).
   - Рёбра (edges): определяют переходы между узлами.
   - Поддерживаются как ациклические (DAG), так и циклические графы.

2. **State (Состояние)**:
   - Состояние графа — это общий объект (обычно словарь), который передаётся между узлами и обновляется в процессе выполнения.
   - Пример: состояние может содержать историю сообщений, результаты инструментов или текущий контекст.
   - Используется `StateGraph` для определения структуры состояния.

3. **Nodes (Узлы)**:
   - Каждый узел — это функция, которая принимает текущее состояние, выполняет действие и возвращает обновлённое состояние.
   - Пример: узел может вызывать LLM, запускать инструмент или принимать решение о следующем шаге.

4. **Edges (Рёбра)**:
   - Рёбра могут быть:
     - **Обычными**: переход от одного узла к другому.
     - **Условными (Conditional Edges)**: выбор следующего узла на основе логики (например, результата LLM).
   - Пример: если инструмент вернул ошибку, перейти к узлу обработки ошибок.

5. **Checkpoints**:
   - LangGraph поддерживает сохранение состояния (чекпоинты), что позволяет возобновлять выполнение графа с определённой точки или откатываться назад.
   - Полезно для длительных процессов или отладки.

6. **Agents**:
   - LangGraph идеально подходит для создания агентов, которые могут итерировать, принимать решения и использовать инструменты.
   - В отличие от `AgentExecutor` в LangChain, LangGraph предоставляет более явный контроль над логикой выполнения.

---

## Основные компоненты

1. **StateGraph**:
   - Класс для создания графа с определённым состоянием.
   - Пример:
     ```python
     from langgraph.graph import StateGraph
     graph = StateGraph(state_schema=dict)
     ```

2. **Nodes**:
   - Добавляются с помощью метода `add_node`.
   - Пример:
     ```python
     def call_llm(state):
         return {"response": llm.invoke(state["input"])}
     graph.add_node("llm_node", call_llm)
     ```

3. **Edges**:
   - Добавляются с помощью `add_edge` или `add_conditional_edges`.
   - Пример условного ребра:
     ```python
     def route(state):
         if "error" in state:
             return "error_handler"
         return "next_node"
     graph.add_conditional_edges("llm_node", route, {"next_node": "next_node", "error_handler": "error_node"})
     ```

4. **Entry and End Points**:
   - Устанавливаются с помощью `set_entry_point` и `set_finish_point`.
   - Пример:
     ```python
     graph.set_entry_point("llm_node")
     graph.set_finish_point("final_node")
     ```

5. **Compilation**:
   - Граф компилируется в исполняемый объект с помощью `compile`.
   - Пример:
     ```python
     app = graph.compile()
     ```

6. **Tools Integration**:
   - LangGraph поддерживает интеграцию с инструментами, аналогичными LangChain, для выполнения внешних действий (например, запуск shell-команд).
   - Пример:
     ```python
     from langchain_core.tools import Tool
     tool = Tool(name="run_shell", func=lambda x: subprocess.run(x, shell=True, capture_output=True, text=True).stdout, description="Run a shell command")
     ```

---

## Основные сценарии использования

1. **Сложные агенты**:
   - Создание агентов с циклической логикой, где они могут повторять действия, пока не достигнут цели (например, ReAct-агенты с итерациями).
   - Пример: агент, который выполняет команду, анализирует результат и решает, повторить или завершить.

2. **Управляемые рабочие процессы**:
   - Построение сложных пайплайнов, где порядок действий зависит от условий (например, обработка данных с ветвлением).
   - Пример: обработка пользовательского запроса с проверкой данных, вызовом API и генерацией ответа.

3. **Долгосрочные процессы**:
   - Использование чекпоинтов для сохранения состояния в многоэтапных задачах.
   - Пример: чат-бот, который сохраняет контекст между сессиями.

4. **Отладка и контроль**:
   - LangGraph предоставляет прозрачную структуру, где каждый шаг (узел) можно отладить отдельно.

---

## Пример реализации

Пример графа для вывода времени на хосте с ограничением итераций:

```
from langgraph.graph import StateGraph, END
from langchain_core.tools import Tool
import subprocess

# Определяем состояние
class State(dict):
    input: str
    output: str
    iterations: int

# Инструмент для выполнения команды
tool = Tool(
    name="run_shell",
    func=lambda x: subprocess.run(x, shell=True, capture_output=True, text=True).stdout,
    description="Run a shell command and return its output"
)

# Узел для выполнения команды
def run_command_node(state: State) -> State:
    result = tool.run(state["input"])
    state["output"] = result
    state["iterations"] += 1
    return state

# Узел для принятия решения
def decide_node(state: State) -> str:
    if state["iterations"] >= 1 and "UTC" in state["output"]:
        return END
    return "run_command"

# Создаём граф
graph = StateGraph(State)

# Добавляем узлы
graph.add_node("run_command", run_command_node)
graph.add_node("decide", decide_node)

# Добавляем рёбра
graph.add_edge("run_command", "decide")
graph.add_conditional_edges("decide", decide_node, {END: END, "run_command": "run_command"})

# Устанавливаем точку входа
graph.set_entry_point("run_command")

# Компилируем граф
app = graph.compile()

# Запускаем
result = app.invoke({"input": "date", "output": "", "iterations": 0})
print(result["output"])
```

**Вывод**:
```
Wed Jul 16 17:47:25 UTC 2025
```

В этом примере граф выполняет команду `date` только один раз, так как условие в `decide_node` останавливает выполнение после первой итерации, если результат валиден.

---

## Ключевые возможности

- **Явный контроль**: В отличие от `AgentExecutor` в LangChain, LangGraph позволяет чётко определять логику переходов между узлами.
- **Гибкость**: Поддерживает сложные рабочие процессы с циклами, ветвлениями и условиями.
- **Чекпоинты**: Возможность сохранять и восстанавливать состояние для длительных процессов.
- **Интеграция**: Работает с инструментами и LLM из экосистемы LangChain.
- **Отладка**: Прозрачная структура графа упрощает отладку каждого шага.

---

## Сравнение с LangChain

| **Характеристика**         | **LangChain**                              | **LangGraph**                              |
|----------------------------|--------------------------------------------|--------------------------------------------|
| **Подход**                 | Высокоуровневый, автоматическое управление | Низкоуровневый, явное управление графом    |
| **Гибкость**               | Ограничена встроенными агентами            | Полная кастомизация рабочего процесса      |
| **Циклы**                  | Ограниченная поддержка (через итерации)    | Полная поддержка циклических графов        |
| **Использование**          | Простые агенты и цепочки                  | Сложные процессы с управляемым состоянием  |
| **Чекпоинты**              | Ограничены памятью                        | Нативная поддержка сохранения состояния    |

---

## Полезные советы

1. **Ограничение итераций**:
   - Используйте счётчик в состоянии (как в примере выше) или условные рёбра для контроля количества циклов.
   - Пример: `if state["iterations"] >= max_iterations: return END`.

2. **Чёткое состояние**:
   - Определяйте структуру состояния заранее, чтобы избежать путаницы при передаче данных между узлами.

3. **Модульность**:
   - Разделяйте логику на небольтые узлы для упрощения отладки и поддержки.

4. **Интеграция с LangChain**:
   - Используйте инструменты, LLM и память из LangChain для создания узлов в LangGraph.

5. **Отладка**:
   - Логируйте состояние на каждом узле для понимания, как данные изменяются в процессе.
   - Используйте LangSmith для визуализации графа и анализа выполнения.

---

## Ресурсы

- **Официальная документация**: [LangGraph Docs](https://langchain-ai.github.io/langgraph/)
- **GitHub**: [LangGraph Repository](https://github.com/langchain-ai/langgraph)
- **LangSmith**: Инструмент для отладки и мониторинга LangGraph-приложений.
- **Примеры**: [LangGraph Tutorials](https://langchain-ai.github.io/langgraph/examples/)

LangGraph — мощный инструмент для создания сложных, управляемых состоянием рабочих процессов с LLM. Он предоставляет больше контроля и гибкости по сравнению с LangChain, особенно для задач, требующих циклической логики или сложных ветвлений. Настройка условий остановки и структуры графа позволяет оптимизировать выполнение для конкретных задач, таких как ограничение числа итераций.